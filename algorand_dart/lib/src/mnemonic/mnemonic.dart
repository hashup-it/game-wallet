import 'dart:typed_data';

import 'package:algorand_dart/src/exceptions/exceptions.dart';
import 'package:algorand_dart/src/mnemonic/word_list.dart';
import 'package:crypto/crypto.dart';

/// On the Algorand blockchain chain, mnemonic keys are generated by converting
/// the user's private key string to an 11-bit integer to the bip-0039 English
/// word list where the integer value maps to the word in the bip-0039
/// English word list with position same as the integer value.
///
/// To illustrate, if an integer value is 2, it will map to the 2nd word on
/// the bip-0039 English word list.
///
/// This process of transforming the private keys to 11-bit integer and mapping
/// it to bip-0039 English word list will generate 24-word mnemonic keys.
/// The bip-0039 English word is made up of about 2048 random words in an
/// array and can also be termed as seed phrase.
///
/// A checksum is added by taking the first two bytes of the hash of the
/// private key and converting them to 11-bit integers and then to their
/// corresponding word in the word list. This word is added to the end of the
/// 24 words to create a 25-word mnemonic.
///
/// Code is based on BIP39 by Furqan Siddiqui.
/// Credits belong to:
/// https://github.com/furqansiddiqui/bip39-mnemonic-php
class Mnemonic {
  static const ALGORAND_WORD_COUNT = 25;

  static const KEY_LEN_BYTES = 32;

  /// The number of words in the mnemonic.
  /// For Algorand, this is default 25.
  final int wordCount;

  /// The entropy used to generate the mnemonic.
  Uint8List? entropy;

  /// The entropy used to generate the mnemonic.
  Uint8List? checksum;

  /// The wordlist used to create the mnemonic.
  WordList? wordList;

  List<int>? binaryChunks;

  Mnemonic._create({this.wordCount = ALGORAND_WORD_COUNT}) {
    if (wordCount != ALGORAND_WORD_COUNT) {
      throw MnemonicException('Mnemonic words count must be 25');
    }
  }

  /// Converts the private 32-byte key into a 25 word mnemonic.
  /// The generated mnemonic includes a checksum.
  /// Each word in the mnemonic represents 11 bits of data, and the last 11 bits
  /// are reserved for the checksum.
  ///
  /// https://developer.algorand.org/docs/features/accounts/#transformation-private-key-to-25-word-mnemonic
  ///
  /// Throws [MnemonicException] when unable to create the seed phrase.
  /// Returns the seed phrase which is a list containing 25 words.
  static Future<List<String>> generate(List<int> seed) async {
    return Mnemonic._create()
        .useEntropy(seed)
        .wordlist(wordList: WordList.english())
        .mnemonic();
  }

  /// Find the seed/entropy of a 25-words seed phrase/mnemonic.
  /// The generated mnemonic includes a checksum.
  /// Each word in the mnemonic represents 11 bits of data, and the last 11 bits
  /// are reserved for the checksum.
  ///
  /// https://developer.algorand.org/docs/features/accounts/#transformation-private-key-to-25-word-mnemonic
  ///
  /// Throws [MnemonicException] when unable to create the seed.
  /// Returns the seed which is the private key of the account.
  static Future<Uint8List> seed(List<String> words) async {
    return Mnemonic._create()
        .wordlist(wordList: WordList.english())
        .words(words);
  }

  Mnemonic useEntropy(List<int> entropy) {
    // Validate the entropy
    if (entropy.length != 32) throw MnemonicException('Invalid entropy length');

    final entropyBits = Uint8List.fromList(entropy);
    this.entropy = entropyBits;
    checksum = _checksum(entropyBits);
    binaryChunks = toUint11List(entropyBits);

    return this;
  }

  /// Set the wordlist to be use.
  Mnemonic wordlist({WordList? wordList}) {
    this.wordList = wordList ?? WordList.english();

    return this;
  }

  /// Generate the seed based on the word list and entropy.
  ///
  /// Throws [MnemonicException] if a mnemonic cannot be created.
  /// Returns the seed/entropy of the mnemonic.
  Uint8List words(List<String> words) {
    final wordList = this.wordList;
    if (wordList == null) throw MnemonicException('Word list is not defined.');

    // Get the checksum word from the seed phrase
    final checksumWord = words.removeLast();
    final binaryChunks = <int>[];

    // Get the index for each (11-bit) word
    for (var word in words) {
      final index = wordList.findIndex(word);
      binaryChunks.add(index);
    }

    // 11 bit binary chunks to 8 bit
    final bytes = toUint8List(binaryChunks);

    if (bytes.length != KEY_LEN_BYTES + 1) {
      throw MnemonicException('Wrong key length');
    }

    if (bytes[KEY_LEN_BYTES] != 0) {
      throw MnemonicException('Unexpected byte from key');
    }

    // Chop the last byte.
    // The last byte was 3 bits, padded with 8 bits to create the 24th word.
    final entropyBits = bytes.sublist(0, KEY_LEN_BYTES);

    // Checksum validation
    final computedChecksum = _checksumWord(entropyBits);
    if (checksumWord != computedChecksum) {
      throw MnemonicException('Checksums do not match.');
    }

    return entropyBits;
  }

  /// Generate the mnemonic based on the word list and entropy.
  ///
  /// Throws [MnemonicException] if a mnemonic cannot be created.
  /// Returns the seed phrase as list of words.
  List<String> mnemonic() {
    if (entropy == null) throw MnemonicException('Entropy is not defined.');

    final checksum = this.checksum;
    if (checksum == null) throw MnemonicException('Checksum is not defined.');

    final wordList = this.wordList;
    if (wordList == null) throw MnemonicException('Word list is not defined.');

    final binaryChunks = this.binaryChunks;
    if (binaryChunks == null) {
      throw MnemonicException('Binary chunks not defined');
    }

    final words = <String>[];
    for (var index in binaryChunks) {
      words.add(wordList.getWord(index));
    }

    // Checksum
    final checksumIndex = toUint11List(checksum)[0];
    words.add(wordList.getWord(checksumIndex));

    return words;
  }

  /// Get the word for the given checksum.
  String _checksumWord(Uint8List entropy) {
    final checksumBytes = _checksum(entropy);
    final checksumIndex = toUint11List(checksumBytes)[0];
    return wordList?.getWord(checksumIndex) ?? '';
  }

  /// Calculate the checksum from the entropy.
  Uint8List _checksum(Uint8List entropy) {
    // Compute the hash
    final digest = sha512256.convert(entropy).bytes;

    // Take the first 2 bytes
    return Uint8List.fromList(digest.sublist(0, 2));
  }

  ///  Convert a bytearray to an list of 11-bit numbers.
  List<int> toUint11List(Uint8List data) {
    var buffer = 0;
    var numOfBits = 0;
    var output = <int>[];

    for (var i in data) {
      buffer |= i << numOfBits;
      numOfBits += 8;

      if (numOfBits >= 11) {
        output.add(buffer & 2047);
        buffer = buffer >> 11;
        numOfBits -= 11;
      }
    }

    if (numOfBits != 0) {
      output.add(buffer & 2047);
    }

    return output;
  }

  /// Convert a list of 11-bit numbers to a bytearray.
  Uint8List toUint8List(List<int> nums) {
    var buffer = 0;
    var numOfBits = 0;
    var output = <int>[];

    for (var i in nums) {
      buffer |= i << numOfBits;
      numOfBits += 11;

      while (numOfBits >= 8) {
        output.add(buffer & 255);
        buffer = buffer >> 8;
        numOfBits -= 8;
      }
    }

    if (numOfBits != 0) {
      output.add(buffer & 255);
    }

    return Uint8List.fromList(output);
  }
}
